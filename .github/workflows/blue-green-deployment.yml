name: Blue-Green Deployment Strategy

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      image_tag:
        required: true
        type: string
      modules:
        required: false
        type: string
        default: 'all'
      rollback:
        required: false
        type: boolean
        default: false
    secrets:
      KUBE_CONFIG:
        required: true
      REGISTRY_TOKEN:
        required: true

permissions:
  contents: read
  packages: write
  deployments: write

concurrency:
  group: blue-green-${{ inputs.environment }}
  cancel-in-progress: false

env:
  ENVIRONMENT: ${{ inputs.environment }}
  IMAGE_TAG: ${{ inputs.image_tag }}
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  prepare-deployment:
    runs-on: ubuntu-latest
    outputs:
      current_slot: ${{ steps.detect.outputs.current_slot }}
      target_slot: ${{ steps.detect.outputs.target_slot }}
      modules: ${{ steps.modules.outputs.modules }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config set-context --current --namespace=semantest-${{ env.ENVIRONMENT }}

      - name: Detect current deployment slot
        id: detect
        run: |
          export KUBECONFIG=kubeconfig
          
          # Check which slot is currently active
          CURRENT_SLOT=$(kubectl get service semantest-service -o jsonpath='{.spec.selector.slot}' 2>/dev/null || echo "green")
          
          if [[ "$CURRENT_SLOT" == "blue" ]]; then
            TARGET_SLOT="green"
          else
            TARGET_SLOT="blue"
          fi
          
          echo "current_slot=$CURRENT_SLOT" >> $GITHUB_OUTPUT
          echo "target_slot=$TARGET_SLOT" >> $GITHUB_OUTPUT
          
          echo "ðŸ” Current active slot: $CURRENT_SLOT"
          echo "ðŸŽ¯ Target deployment slot: $TARGET_SLOT"

      - name: Determine modules to deploy
        id: modules
        run: |
          if [[ "${{ inputs.modules }}" == "all" ]]; then
            modules='["core", "browser", "google.com", "images.google.com", "chatgpt.com", "extension.chrome", "nodejs.server", "typescript.client", "ar-vr"]'
          else
            # Convert comma-separated list to JSON array
            modules=$(echo "${{ inputs.modules }}" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$"; ""))')
          fi
          
          echo "modules=$modules" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Modules to deploy: $modules"

  deploy-target-slot:
    runs-on: ubuntu-latest
    needs: prepare-deployment
    if: ${{ !inputs.rollback }}
    strategy:
      matrix:
        module: ${{ fromJson(needs.prepare-deployment.outputs.modules) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config set-context --current --namespace=semantest-${{ env.ENVIRONMENT }}

      - name: Deploy to ${{ needs.prepare-deployment.outputs.target_slot }} slot
        run: |
          export KUBECONFIG=kubeconfig
          TARGET_SLOT="${{ needs.prepare-deployment.outputs.target_slot }}"
          MODULE="${{ matrix.module }}"
          
          echo "ðŸš€ Deploying $MODULE to $TARGET_SLOT slot in ${{ env.ENVIRONMENT }}"
          
          # Create deployment manifest
          cat > deployment-$MODULE-$TARGET_SLOT.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: semantest-$MODULE-$TARGET_SLOT
            namespace: semantest-${{ env.ENVIRONMENT }}
            labels:
              app: semantest
              module: $MODULE
              slot: $TARGET_SLOT
              environment: ${{ env.ENVIRONMENT }}
              version: ${{ env.IMAGE_TAG }}
          spec:
            replicas: 3
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxUnavailable: 0
                maxSurge: 1
            selector:
              matchLabels:
                app: semantest
                module: $MODULE
                slot: $TARGET_SLOT
            template:
              metadata:
                labels:
                  app: semantest
                  module: $MODULE
                  slot: $TARGET_SLOT
                  version: ${{ env.IMAGE_TAG }}
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "3000"
                  prometheus.io/path: "/metrics"
              spec:
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1001
                  fsGroup: 1001
                serviceAccountName: semantest-service-account
                containers:
                - name: $MODULE
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$MODULE:${{ env.IMAGE_TAG }}
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 3000
                    name: http
                    protocol: TCP
                  env:
                  - name: NODE_ENV
                    value: "${{ env.ENVIRONMENT }}"
                  - name: VERSION
                    value: "${{ env.IMAGE_TAG }}"
                  - name: SLOT
                    value: "$TARGET_SLOT"
                  - name: MODULE
                    value: "$MODULE"
                  envFrom:
                  - configMapRef:
                      name: semantest-config
                  - secretRef:
                      name: semantest-secrets
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "100m"
                    limits:
                      memory: "1Gi"
                      cpu: "1000m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 60
                    periodSeconds: 30
                    timeoutSeconds: 10
                    successThreshold: 1
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                    successThreshold: 1
                    failureThreshold: 3
                  securityContext:
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: true
                    capabilities:
                      drop:
                      - ALL
                  volumeMounts:
                  - name: tmp
                    mountPath: /tmp
                  - name: cache
                    mountPath: /app/.cache
                volumes:
                - name: tmp
                  emptyDir: {}
                - name: cache
                  emptyDir: {}
                terminationGracePeriodSeconds: 60
          EOF
          
          # Apply deployment
          kubectl apply -f deployment-$MODULE-$TARGET_SLOT.yaml
          
          # Wait for deployment to be ready
          echo "â³ Waiting for $MODULE deployment to be ready..."
          kubectl rollout status deployment/semantest-$MODULE-$TARGET_SLOT --timeout=600s
          
          echo "âœ… $MODULE deployed successfully to $TARGET_SLOT slot"

  health-check:
    runs-on: ubuntu-latest
    needs: [prepare-deployment, deploy-target-slot]
    if: ${{ !inputs.rollback }}
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config set-context --current --namespace=semantest-${{ env.ENVIRONMENT }}

      - name: Comprehensive health check
        run: |
          export KUBECONFIG=kubeconfig
          TARGET_SLOT="${{ needs.prepare-deployment.outputs.target_slot }}"
          
          echo "ðŸ¥ Starting comprehensive health check for $TARGET_SLOT slot"
          
          # Create health check script
          cat > health-check.sh << 'EOF'
          #!/bin/bash
          
          TARGET_SLOT="$1"
          ENVIRONMENT="$2"
          MAX_RETRIES=30
          RETRY_INTERVAL=10
          
          echo "Starting health check for $TARGET_SLOT slot in $ENVIRONMENT"
          
          # Check all pods are running
          echo "ðŸ“Š Checking pod status..."
          kubectl get pods -l slot=$TARGET_SLOT --no-headers | while read line; do
            pod_name=$(echo $line | awk '{print $1}')
            pod_status=$(echo $line | awk '{print $3}')
            
            if [[ "$pod_status" != "Running" ]]; then
              echo "âŒ Pod $pod_name is not running: $pod_status"
              exit 1
            else
              echo "âœ… Pod $pod_name is running"
            fi
          done
          
          # Health check endpoints
          echo "ðŸ” Testing health endpoints..."
          
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            ALL_HEALTHY=true
            
            # Get all service endpoints for the target slot
            kubectl get pods -l slot=$TARGET_SLOT -o jsonpath='{.items[*].status.podIP}' | tr ' ' '\n' | while read pod_ip; do
              if [[ -n "$pod_ip" ]]; then
                # Test health endpoint
                if kubectl run test-health-$RANDOM --rm -i --restart=Never --image=curlimages/curl -- curl -f -s --max-time 5 "http://$pod_ip:3000/health" > /dev/null 2>&1; then
                  echo "âœ… Health check passed for $pod_ip"
                else
                  echo "âŒ Health check failed for $pod_ip"
                  ALL_HEALTHY=false
                fi
                
                # Test readiness endpoint
                if kubectl run test-ready-$RANDOM --rm -i --restart=Never --image=curlimages/curl -- curl -f -s --max-time 5 "http://$pod_ip:3000/ready" > /dev/null 2>&1; then
                  echo "âœ… Readiness check passed for $pod_ip"
                else
                  echo "âŒ Readiness check failed for $pod_ip"
                  ALL_HEALTHY=false
                fi
              fi
            done
            
            if $ALL_HEALTHY; then
              echo "âœ… All health checks passed"
              exit 0
            else
              echo "â³ Some health checks failed, retrying... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep $RETRY_INTERVAL
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          echo "âŒ Health checks failed after $MAX_RETRIES attempts"
          exit 1
          EOF
          
          chmod +x health-check.sh
          ./health-check.sh "$TARGET_SLOT" "${{ env.ENVIRONMENT }}"

      - name: Performance validation
        run: |
          export KUBECONFIG=kubeconfig
          TARGET_SLOT="${{ needs.prepare-deployment.outputs.target_slot }}"
          
          echo "âš¡ Running performance validation..."
          
          # Get a sample pod IP for testing
          POD_IP=$(kubectl get pods -l slot=$TARGET_SLOT -o jsonpath='{.items[0].status.podIP}')
          
          if [[ -n "$POD_IP" ]]; then
            # Run basic performance test
            kubectl run perf-test-$RANDOM --rm -i --restart=Never --image=curlimages/curl -- \
              sh -c "
                echo 'Testing response time...'
                for i in \$(seq 1 10); do
                  time curl -f -s --max-time 10 http://$POD_IP:3000/health > /dev/null
                done
              "
            
            echo "âœ… Performance validation completed"
          else
            echo "âŒ Could not find pod IP for performance testing"
            exit 1
          fi

  traffic-switch:
    runs-on: ubuntu-latest
    needs: [prepare-deployment, deploy-target-slot, health-check]
    if: ${{ !inputs.rollback }}
    environment:
      name: ${{ inputs.environment }}-production
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config set-context --current --namespace=semantest-${{ env.ENVIRONMENT }}

      - name: Switch traffic to target slot
        run: |
          export KUBECONFIG=kubeconfig
          TARGET_SLOT="${{ needs.prepare-deployment.outputs.target_slot }}"
          CURRENT_SLOT="${{ needs.prepare-deployment.outputs.current_slot }}"
          
          echo "ðŸ”„ Switching traffic from $CURRENT_SLOT to $TARGET_SLOT"
          
          # Update service selector to point to target slot
          kubectl patch service semantest-service -p '{"spec":{"selector":{"slot":"'$TARGET_SLOT'"}}}'
          
          # Verify traffic switch
          sleep 10
          ACTIVE_SLOT=$(kubectl get service semantest-service -o jsonpath='{.spec.selector.slot}')
          
          if [[ "$ACTIVE_SLOT" == "$TARGET_SLOT" ]]; then
            echo "âœ… Traffic successfully switched to $TARGET_SLOT"
          else
            echo "âŒ Traffic switch failed. Current slot: $ACTIVE_SLOT"
            exit 1
          fi

      - name: Post-switch validation
        run: |
          export KUBECONFIG=kubeconfig
          TARGET_SLOT="${{ needs.prepare-deployment.outputs.target_slot }}"
          
          echo "ðŸ” Running post-switch validation..."
          
          # Get service endpoint
          SERVICE_IP=$(kubectl get service semantest-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [[ -n "$SERVICE_IP" ]]; then
            # Test service endpoint
            kubectl run post-switch-test-$RANDOM --rm -i --restart=Never --image=curlimages/curl -- \
              curl -f -s --max-time 10 "http://$SERVICE_IP/health"
            
            echo "âœ… Post-switch validation completed"
          else
            echo "âš ï¸ Could not get service IP, testing internal service..."
            kubectl run post-switch-test-$RANDOM --rm -i --restart=Never --image=curlimages/curl -- \
              curl -f -s --max-time 10 "http://semantest-service/health"
          fi

  cleanup-old-slot:
    runs-on: ubuntu-latest
    needs: [prepare-deployment, traffic-switch]
    if: ${{ !inputs.rollback }}
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config set-context --current --namespace=semantest-${{ env.ENVIRONMENT }}

      - name: Scale down old slot
        run: |
          export KUBECONFIG=kubeconfig
          CURRENT_SLOT="${{ needs.prepare-deployment.outputs.current_slot }}"
          
          echo "ðŸ§¹ Scaling down old slot: $CURRENT_SLOT"
          
          # Scale down old deployments (keep them for quick rollback)
          kubectl get deployments -l slot=$CURRENT_SLOT -o name | while read deployment; do
            echo "Scaling down $deployment"
            kubectl scale $deployment --replicas=1
          done
          
          echo "âœ… Old slot scaled down (kept 1 replica for rollback)"

  rollback:
    runs-on: ubuntu-latest
    needs: prepare-deployment
    if: ${{ inputs.rollback }}
    environment:
      name: ${{ inputs.environment }}-rollback
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config set-context --current --namespace=semantest-${{ env.ENVIRONMENT }}

      - name: Rollback to previous slot
        run: |
          export KUBECONFIG=kubeconfig
          CURRENT_SLOT="${{ needs.prepare-deployment.outputs.current_slot }}"
          TARGET_SLOT="${{ needs.prepare-deployment.outputs.target_slot }}"
          
          echo "ðŸ”„ Rolling back from $CURRENT_SLOT to $TARGET_SLOT"
          
          # Scale up the previous slot
          kubectl get deployments -l slot=$TARGET_SLOT -o name | while read deployment; do
            echo "Scaling up $deployment for rollback"
            kubectl scale $deployment --replicas=3
          done
          
          # Wait for deployments to be ready
          kubectl get deployments -l slot=$TARGET_SLOT -o name | while read deployment; do
            kubectl rollout status $deployment --timeout=300s
          done
          
          # Switch traffic back
          kubectl patch service semantest-service -p '{"spec":{"selector":{"slot":"'$TARGET_SLOT'"}}}'
          
          # Verify rollback
          sleep 10
          ACTIVE_SLOT=$(kubectl get service semantest-service -o jsonpath='{.spec.selector.slot}')
          
          if [[ "$ACTIVE_SLOT" == "$TARGET_SLOT" ]]; then
            echo "âœ… Rollback successful. Active slot: $TARGET_SLOT"
          else
            echo "âŒ Rollback failed. Current slot: $ACTIVE_SLOT"
            exit 1
          fi

      - name: Rollback notification
        run: |
          echo "ðŸ“§ Sending rollback notification..."
          
          cat > rollback-report.json << EOF
          {
            "type": "rollback",
            "environment": "${{ env.ENVIRONMENT }}",
            "from_slot": "${{ needs.prepare-deployment.outputs.current_slot }}",
            "to_slot": "${{ needs.prepare-deployment.outputs.target_slot }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "trigger": "manual",
            "status": "completed"
          }
          EOF
          
          echo "Rollback completed and logged"

  deployment-summary:
    runs-on: ubuntu-latest
    needs: [prepare-deployment, deploy-target-slot, health-check, traffic-switch, cleanup-old-slot, rollback]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "ðŸ“Š Blue-Green Deployment Summary"
          echo "================================"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Image Tag: ${{ env.IMAGE_TAG }}"
          echo "Modules: ${{ inputs.modules }}"
          echo "Rollback: ${{ inputs.rollback }}"
          echo "Current Slot: ${{ needs.prepare-deployment.outputs.current_slot }}"
          echo "Target Slot: ${{ needs.prepare-deployment.outputs.target_slot }}"
          echo ""
          
          if [[ "${{ inputs.rollback }}" == "true" ]]; then
            echo "ðŸ”„ Rollback Operation Completed"
          else
            echo "ðŸš€ Deployment Operation Completed"
          fi
          
          echo ""
          echo "Job Results:"
          echo "- Prepare: ${{ needs.prepare-deployment.result }}"
          echo "- Deploy: ${{ needs.deploy-target-slot.result }}"
          echo "- Health Check: ${{ needs.health-check.result }}"
          echo "- Traffic Switch: ${{ needs.traffic-switch.result }}"
          echo "- Cleanup: ${{ needs.cleanup-old-slot.result }}"
          echo "- Rollback: ${{ needs.rollback.result }}"